<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1 Point Perspective Tunnel</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #ffffff; /* Beyaz Arka Plan */
        }
        canvas { display: block; }
    </style>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. SAHNE VE KAMERA ---
        const scene = new THREE.Scene();
        // Sonsuzluk için beyaz sis. Sondaki 0.0015 yoğunluğu belirler.
        scene.fog = new THREE.FogExp2(0xffffff, 0.0015);
        scene.background = new THREE.Color(0xffffff);

        // FOV (Field of View) 90 yaptık ki hız hissi artsın
        const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. KÜPLERİ OLUŞTURMA ---
        const cubes = [];
        const cubeCount = 600; // Küp sayısı
        const tunnelRadius = 50; // Tünelin genişliği
        
        // Ortak Geometri ve Materyal (Performans için)
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const fillMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // İçi beyaz
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }); // Kenarları siyah

        for (let i = 0; i < cubeCount; i++) {
            // Grup oluştur (Küp + Çizgiler beraber hareket etsin diye)
            const group = new THREE.Group();

            // 1. Beyaz Küp
            const mesh = new THREE.Mesh(geometry, fillMaterial);
            // 2. Siyah Kenar Çizgileri
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, lineMaterial);

            group.add(mesh);
            group.add(line);

            // RASTGELE KONUMLANDIRMA (Tünel Mantığı)
            // Amaç: Ortası boş kalsın (1 Point Perspective için)
            
            // Açıyı rastgele seç (0 - 360 derece)
            const angle = Math.random() * Math.PI * 2;
            // Merkeze olan uzaklığı rastgele seç (En az 10 birim uzakta olsun ki ortası delik olsun)
            const radius = 10 + Math.random() * tunnelRadius;
            
            group.position.x = Math.cos(angle) * radius;
            group.position.y = Math.sin(angle) * radius;
            
            // Derinlik (Z ekseni) boyunca rastgele dağıt
            group.position.z = Math.random() * -1000;

            // Rastgele boyutlandır
            const scale = 1 + Math.random() * 4;
            group.scale.set(scale, scale, scale);

            // Rastgele döndür (daha organik dursun)
            group.rotation.set(Math.random(), Math.random(), Math.random());

            scene.add(group);
            cubes.push(group);
        }

        camera.position.z = 50; // Kamerayı biraz geriye alalım

        // --- 3. SCROLL KONTROLÜ ---
        let speed = 0; // Anlık hız
        let scrollPos = 0;

        window.addEventListener('wheel', (event) => {
            // Scroll yönüne göre hız ver
            // DeltaY genelde 100 gelir, onu küçültüyoruz
            speed += event.deltaY * 0.002;
        });

        // --- 4. ANİMASYON ---
        const animate = function () {
            requestAnimationFrame(animate);

            // Hızın zamanla yavaşlaması (Sürtünme etkisi)
            speed *= 0.95; 
            
            // Kamerayı ilerlet
            camera.position.z -= speed;

            // Küpleri kontrol et
            cubes.forEach(cube => {
                // Kendi etrafında yavaşça dönsünler (Estetik)
                cube.rotation.x += 0.002;
                cube.rotation.y += 0.002;

                // SONSUZLUK DÖNGÜSÜ (Teleport)
                // Eğer küp kameranın arkasında kalırsa (kamera Z'sinden büyükse)
                if (cube.position.z > camera.position.z) {
                    // Küpü en ileriye (sise) ışınla
                    cube.position.z -= 1000; 
                    
                    // Işınlanınca yerini azıcık değiştir ki desen tekrarı belli olmasın
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * tunnelRadius;
                    cube.position.x = Math.cos(angle) * radius;
                    cube.position.y = Math.sin(angle) * radius;
                }
                
                // Geri geri gidersek diye ters kontrol
                if (cube.position.z < camera.position.z - 1000) {
                    cube.position.z += 1000;
                }
            });

            renderer.render(scene, camera);
        };

        animate();

        // Ekran boyutu değişirse düzelt
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
