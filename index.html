<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@900&family=Inter:wght@300;500;800&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: transparent;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            cursor: none; /* Mouse imlecini gizledik, çünkü kendi sürümüz var */
        }
        body.grabbing { cursor: none; }

        /* VİDEO AYARLARI */
        #bgVideo {
            position: fixed;
            right: 0; bottom: 0;
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            z-index: -2;
            object-fit: cover;
            opacity: 0.8; /* Videoyu biraz soldurduk ki siyah yazılar net görünsün */
        }

        #canvas1 { 
            display: block; 
            width: 100vw; height: 100vh;
            position: relative; z-index: 1; 
        }

        /* --- YAN BİLGİ PANELİ --- */
        #sidePanel {
            position: fixed;
            top: 0;
            width: 350px; height: 100%;
            background: rgba(255, 255, 255, 0.9); /* Açık renk zemin (Siyah tema için) */
            backdrop-filter: blur(12px);
            padding: 40px;
            color: #000; /* Siyah yazı */
            z-index: 10;
            transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 0 40px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
        }
        
        #sidePanel.right {
            right: 0; left: auto;
            transform: translateX(100%);
            border-left: 1px solid rgba(0,0,0,0.1);
        }
        #sidePanel.right.active { transform: translateX(0); }

        #sidePanel.left {
            left: 0; right: auto;
            transform: translateX(-100%);
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        #sidePanel.left.active { transform: translateX(0); }

        #panelTitle {
            font-family: 'Playfair Display', serif;
            font-size: 32px; margin-bottom: 20px;
            color: #000; 
        }
        #panelDesc {
            font-size: 16px; line-height: 1.6; color: #333; margin-bottom: 30px;
        }
        #closeBtn {
            position: absolute; top: 20px; right: 20px;
            background: none; border: none; color: #000;
            font-size: 24px; cursor: pointer;
        }
        #closeBtn:hover { color: #555; }

        .info {
            position: absolute; bottom: 20px; left: 20px;
            color: #000; font-size: 13px; pointer-events: none; user-select: none;
            background: rgba(255,255,255,0.6); padding: 8px 12px; border-radius: 8px;
            z-index: 2; 
        }
    </style>
</head>
<body>
    <video autoplay muted loop playsinline id="bgVideo">
        <source src="bg.mp4" type="video/mp4">
        Tarayıcınız video etiketini desteklemiyor.
    </video>

    <div id="sidePanel" class="right">
        <button id="closeBtn">&times;</button>
        <h2 id="panelTitle">Başlık</h2>
        <p id="panelDesc">Detaylar...</p>
        <div style="margin-top: auto; font-size: 12px; color: #555;">
            ● exploration made easy
        </div>
    </div>

    <canvas id="canvas1"></canvas>
    <div class="info">exploration made easy</div>

    <script>
        const mainNodeText = "hey!";

        const myData = {
            nodes: [
                { id: mainNodeText, group: 'main', val: 100, desc: "Burası benim kişisel evrenim. Hoş geldin." },
                { id: 'TEKNOLOJİ', group: 'cat', val: 50, parent: mainNodeText, desc: "Kod, devreler ve silikon vadisi maceralarım." },
                { id: 'FİZİK & BİLİM', group: 'cat', val: 50, parent: mainNodeText, desc: "Evrenin nasıl çalıştığını anlama çabam." },
                { id: 'SANAT & TASARIM', group: 'cat', val: 50, parent: mainNodeText, desc: "Estetik, renkler ve dijital sanat." },
                { id: 'YAŞAM', group: 'cat', val: 50, parent: mainNodeText, desc: "Hobilerim, gezilerim ve yaşam tarzım." },
                { id: 'Yazılım', group: 'sub', val: 30, parent: 'TEKNOLOJİ', desc: "Backend, Frontend ve ötesi." },
                { id: 'Robotik', group: 'sub', val: 30, parent: 'TEKNOLOJİ', desc: "Hareket eden makineler." },
                { id: 'Python', group: 'item', val: 15, parent: 'Yazılım', desc: "Veri bilimi ve otomasyon için favori dilim." },
                { id: 'Three.js', group: 'item', val: 15, parent: 'Yazılım', desc: "Web üzerinde 3D dünyalar yaratmak." },
                { id: 'GitHub', group: 'item', val: 12, parent: 'Yazılım', desc: "Açık kaynak katkılarım." },
                { id: 'Arduino', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Pixhawk', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Jetson Xavier', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Simülasyon', group: 'sub', val: 30, parent: 'FİZİK & BİLİM' },
                { id: 'Teori', group: 'sub', val: 30, parent: 'FİZİK & BİLİM' },
                { id: 'Yörünge Mekaniği', group: 'item', val: 15, parent: 'Simülasyon' },
                { id: 'Euler Metodu', group: 'item', val: 15, parent: 'Simülasyon' },
                { id: 'NumPy', group: 'item', val: 12, parent: 'Simülasyon' },
                { id: 'Lineer Cebir', group: 'item', val: 15, parent: 'Teori' },
                { id: 'Solucan Delikleri', group: 'item', val: 12, parent: 'Teori' },
                { id: '3D Modelleme', group: 'sub', val: 30, parent: 'SANAT & TASARIM' },
                { id: 'Görsel Estetik', group: 'sub', val: 30, parent: 'SANAT & TASARIM' },
                { id: 'Blender', group: 'item', val: 15, parent: '3D Modelleme', desc: "3D modeller ve renderlar." },
                { id: 'Renk Teorisi', group: 'item', val: 12, parent: 'Görsel Estetik', desc: "Renklerin psikolojisi ve uyumu." },
                { id: 'Fraktallar', group: 'item', val: 15, parent: 'Görsel Estetik' },
                { id: 'Minimalizm', group: 'item', val: 12, parent: 'Görsel Estetik' },
                { id: 'Kariyer', group: 'sub', val: 30, parent: 'YAŞAM' },
                { id: 'Hobiler', group: 'sub', val: 30, parent: 'YAŞAM' },
                { id: 'Erasmus', group: 'item', val: 15, parent: 'Kariyer' },
                { id: 'Fransızca', group: 'item', val: 12, parent: 'Kariyer' },
                { id: 'Calisthenics', group: 'item', val: 15, parent: 'Hobiler' },
                { id: 'Handstand', group: 'item', val: 12, parent: 'Hobiler' },
                { id: 'Moda', group: 'item', val: 12, parent: 'Hobiler' }
            ]
        };

        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        const sidePanel = document.getElementById('sidePanel');
        const panelTitle = document.getElementById('panelTitle');
        const panelDesc = document.getElementById('panelDesc');
        const closeBtn = document.getElementById('closeBtn');

        let width, height;
        let particles = [];
        let particleMap = {};
        let auraParticles = []; 
        let activeNode = null; 

        // Mouse Sürüsü için değişkenler
        let cursorParticles = [];

        let camera = { 
            x: 0, y: 0, zoom: 1, 
            targetX: 0, targetY: 0, 
            isDragging: false, startX: 0, startY: 0 
        };
        let mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };

        function closePanel() {
            sidePanel.classList.remove('active');
            activeNode = null;
            auraParticles = []; 
            camera.targetX = width/2;
            camera.targetY = height/2;
        }

        closeBtn.addEventListener('click', closePanel);

        window.addEventListener('mousedown', e => {
            if(e.target.closest('#sidePanel')) return;
            camera.isDragging = true;
            camera.startX = e.clientX - camera.x;
            camera.startY = e.clientY - camera.y;
        });
        window.addEventListener('mouseup', () => {
            camera.isDragging = false;
        });
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (camera.isDragging) {
                camera.x = e.clientX - camera.startX;
                camera.y = e.clientY - camera.startY;
                camera.targetX = camera.x;
                camera.targetY = camera.y;
            }
            mouse.worldX = (mouse.x - camera.x) / camera.zoom;
            mouse.worldY = (mouse.y - camera.y) / camera.zoom;
        });
        window.addEventListener('wheel', e => {
            e.preventDefault();
            const s = 0.001;
            const newZoom = Math.max(0.2, Math.min(camera.zoom - e.deltaY * s, 4));
            const wx = (mouse.x - camera.x) / camera.zoom;
            const wy = (mouse.y - camera.y) / camera.zoom;
            camera.zoom = newZoom;
            camera.x = mouse.x - wx * camera.zoom;
            camera.y = mouse.y - wy * camera.zoom;
            camera.targetX = camera.x;
            camera.targetY = camera.y;
        }, { passive: false });


        // --- MOUSE SÜRÜSÜ SINIFI ---
        class CursorSwarm {
            constructor() {
                this.x = mouse.x;
                this.y = mouse.y;
                this.size = Math.random() * 2 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.05 + Math.random() * 0.05;
                this.offset = Math.random() * 20;
            }

            update() {
                // Mouse'u takip et (Lerp - Gecikmeli takip)
                // Hedef nokta: Mouse konumu + etrafında dönme hareketi
                this.angle += 0.05;
                let targetX = mouse.x + Math.cos(this.angle) * this.offset;
                let targetY = mouse.y + Math.sin(this.angle) * this.offset;

                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;
            }

            draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Siyah parçacıklar
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- KALICI AURA PARÇACIĞI (Siyah versiyon) ---
        class AuraParticle {
            constructor(originX, originY, type) {
                this.originX = originX;
                this.originY = originY;
                this.type = type;
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 50 + Math.random() * 150; 
                this.x = this.originX + Math.cos(this.angle) * this.radius;
                this.y = this.originY + Math.sin(this.angle) * this.radius;
                this.angularSpeed = (Math.random() - 0.5) * 0.02;
                this.radialSpeed = Math.random() * 0.5;
                this.originalRadius = this.radius;
                this.life = 0; 
                this.maxLife = 0.6 + Math.random() * 0.4; 

                // Aura renkleri (Daha pastel ve koyu)
                if (type.includes('SANAT')) {
                    this.color = `rgba(100, 50, 50, 0.4)`; 
                    this.size = Math.random() * 4 + 2;
                } else if (type.includes('TEKNOLOJİ')) {
                    this.color = `rgba(50, 80, 50, 0.4)`; 
                    this.size = Math.random() * 3 + 1; 
                } else if (type.includes('FİZİK')) {
                    this.color = `rgba(50, 50, 80, 0.4)`;
                    this.size = Math.random() * 2 + 1;
                } else {
                    this.color = 'rgba(50, 50, 50, 0.4)'; 
                    this.size = Math.random() * 3 + 1;
                }
            }

            update() {
                if (this.life < this.maxLife) this.life += 0.02;
                this.angle += this.angularSpeed;
                let pulse = Math.sin(Date.now() * 0.002 + this.originalRadius) * 20;
                let currentRadius = this.originalRadius + pulse;
                this.x = this.originX + Math.cos(this.angle) * currentRadius;
                this.y = this.originY + Math.sin(this.angle) * currentRadius;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                if (this.type.includes('TEKNOLOJİ')) {
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                } else {
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        function createAura(node) {
            auraParticles = []; 
            let type = node.group === 'cat' ? node.id : (node.parent || node.id);
            for(let i=0; i<60; i++) {
                auraParticles.push(new AuraParticle(node.x, node.y + node.floatOffset, type));
            }
        }

        class Particle {
            constructor(data) {
                this.id = data.id;
                this.group = data.group;
                this.val = data.val;
                this.parentId = data.parent;
                this.desc = data.desc || "Keşfedilmeyi bekleyen bir düğüm...";
                this.destX = 0; this.destY = 0;
                this.x = 0; this.y = 0;
                this.visible = (this.group === 'main');
                this.scale = this.visible ? 1 : 0; 
                this.opacity = this.visible ? 1 : 0;
                this.floatAngle = Math.random()*Math.PI*2;
                this.floatSpeed = 0.001 + Math.random()*0.002;
                this.floatOffset = 0;
                this.hovered = false;
                this.seed = this.id.charCodeAt(0) + (this.id.charCodeAt(this.id.length-1) || 0);
            }

            update() {
                if (!this.visible) return;
                this.x += (this.destX - this.x) * 0.08; 
                this.y += (this.destY - this.y) * 0.08;
                if (this.scale < 1) this.scale += (1 - this.scale) * 0.1;
                if (this.opacity < 1) this.opacity += (1 - this.opacity) * 0.1;

                let dist = Math.hypot(this.destX - this.x, this.destY - this.y);
                if (dist < 2) {
                    this.floatAngle += this.floatSpeed;
                    this.floatOffset = Math.sin(this.floatAngle) * 4; 
                }

                let textW = this.val * 3 + 50; 
                let textH = this.val + 30;
                if (mouse.worldX > this.x - textW/2 && mouse.worldX < this.x + textW/2 &&
                    mouse.worldY > this.y - textH/2 + this.floatOffset && mouse.worldY < this.y + textH/2 + this.floatOffset) {
                    this.hovered = true;
                } else {
                    this.hovered = false;
                }
            }

            draw() {
                if (!this.visible || this.opacity < 0.01) return;
                ctx.save();
                ctx.translate(this.x, this.y + this.floatOffset);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let fontSize = 14;
                let color = '#000000'; // DÜZ SİYAH

                if (this.group === 'main') {
                    fontSize = 50; 
                    ctx.font = `900 ${fontSize}px 'Playfair Display', serif`;
                } else if (this.group === 'cat') {
                    fontSize = 28; 
                    ctx.font = `800 ${fontSize}px 'Inter', sans-serif`; 
                    color = '#111';
                } else if (this.group === 'sub') {
                    fontSize = 18; 
                    ctx.font = `600 ${fontSize}px 'Inter', sans-serif`; 
                    color = '#222';
                } else {
                    fontSize = 14; 
                    ctx.font = `400 ${fontSize}px 'JetBrains Mono', monospace`; 
                    color = '#333';
                }

                // Neon yok, Kontür var (Video üstünde okunabilirlik için)
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ffffff'; // Beyaz dış hat
                ctx.strokeText(this.id, 0, 0);

                ctx.fillStyle = color;
                ctx.fillText(this.id, 0, 0);
                
                ctx.restore();
            }
        }

        function calculateLayout() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            
            if(camera.x === 0 && camera.y === 0) {
                camera.x = width / 2; camera.y = height / 2;
                camera.targetX = camera.x; camera.targetY = camera.y;
            }
            
            // Mouse sürüsü init
            if(cursorParticles.length === 0) {
                for(let i=0; i<12; i++) {
                    cursorParticles.push(new CursorSwarm());
                }
            }

            if (particles.length === 0) {
                myData.nodes.forEach(node => {
                    let p = new Particle(node);
                    particles.push(p);
                    particleMap[node.id] = p;
                });
            }

            let pMain = particles.find(p => p.group === 'main');
            if (pMain) {
                pMain.destX = 0; pMain.destY = 0;
                if(!pMain.visible) { pMain.x = 0; pMain.y = 0; }
            }

            let cats = particles.filter(p => p.group === 'cat');
            let r1 = 300;
            cats.forEach((p, i) => {
                let angle = (Math.PI*2 / cats.length) * i - Math.PI/2;
                p.destX = Math.cos(angle) * r1;
                p.destY = Math.sin(angle) * r1;
                
                let subs = particles.filter(sub => sub.parentId === p.id);
                if (subs.length > 0) {
                    let spread = Math.PI / 1.8;
                    let startA = angle - spread/2;
                    let r2 = r1 + 280;
                    subs.forEach((sub, j) => {
                        let subA = startA + (spread/(subs.length+1))*(j+1);
                        sub.destX = Math.cos(subA) * r2;
                        sub.destY = Math.sin(subA) * r2;
                        let items = particles.filter(it => it.parentId === sub.id);
                        if (items.length > 0) {
                            let itemBaseA = Math.atan2(sub.destY, sub.destX);
                            let r3 = 200;
                            items.forEach((item, k) => {
                                let offset = (k - (items.length-1)/2) * 0.35;
                                let itemA = itemBaseA + offset;
                                item.destX = sub.destX + Math.cos(itemA) * r3;
                                item.destY = sub.destY + Math.sin(itemA) * r3;
                            });
                        }
                    });
                }
            });
        }

        function drawOrganicLinks() {
            ctx.globalCompositeOperation = 'source-over'; // Siyah için normal mod
            let time = Date.now() * 0.001; 

            particles.forEach(p => {
                if (!p.visible || !p.parentId || p.opacity < 0.1) return;
                let parent = particleMap[p.parentId];
                if (!parent) return;

                let startX = parent.x; 
                let startY = parent.y + parent.floatOffset;
                let endX = p.x;
                let endY = p.y + p.floatOffset;

                let dist = Math.hypot(endX - startX, endY - startY);
                if (dist < 10) return;

                ctx.globalAlpha = p.opacity * 0.6; 

                let dx = endX - startX;
                let dy = endY - startY;
                let perpX = -dy / dist;
                let perpY = dx / dist;
                let noiseIntensity = Math.min(dist * 0.25, 150); 
                let t1 = 0.3; 
                let noise1 = Math.sin(p.seed * 0.1 + time) * noiseIntensity;
                let cp1X = startX + dx * t1 + perpX * noise1;
                let cp1Y = startY + dy * t1 + perpY * noise1;
                let t2 = 0.7; 
                let noise2 = Math.cos(p.seed * 0.15 + time * 1.2) * -noiseIntensity; 
                let cp2X = startX + dx * t2 + perpX * noise2;
                let cp2Y = startY + dy * t2 + perpY * noise2;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
                
                // KOYU ÇİZGİLER
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.lineWidth = 1.5; 
                ctx.stroke();
                
                ctx.globalAlpha = 1;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, width, height);

            camera.x += (camera.targetX - camera.x) * 0.08;
            camera.y += (camera.targetY - camera.y) * 0.08;

            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            drawOrganicLinks();
            
            for(let i = 0; i < auraParticles.length; i++) {
                auraParticles[i].update();
                auraParticles[i].draw();
            }

            let isHovering = false;
            particles.forEach(p => {
                p.update();
                p.draw();
                if(p.hovered) isHovering = true;
            });

            ctx.restore(); // Kamera dünyasından çık (Ekran koordinatlarına dön)

            // --- MOUSE SÜRÜSÜNÜ ÇİZ ---
            // Bunu restore'dan sonra yapıyoruz ki zoom/pan'dan etkilenmesin, hep mouse ucunda olsun
            for(let i=0; i<cursorParticles.length; i++) {
                cursorParticles[i].update();
                cursorParticles[i].draw();
            }
        }

        function handleNodeClick(node) {
            if (activeNode === node) {
                closePanel();
                return;
            }

            activeNode = node;

            let children = particles.filter(p => p.parentId === node.id && !p.visible);
            if (children.length > 0) {
                children.forEach(child => {
                    child.x = node.x; child.y = node.y;
                    child.scale = 0; child.visible = true;
                });
            }

            createAura(node);

            sidePanel.classList.remove('active'); 
            
            let panelWidth = 350;
            let targetX = 0;

            if (node.destX > 0) {
                sidePanel.classList.remove('right');
                sidePanel.classList.add('left');
                let screenTargetX = (panelWidth + width) / 2;
                targetX = screenTargetX - (node.destX * camera.zoom);

            } else {
                sidePanel.classList.remove('left');
                sidePanel.classList.add('right');
                let screenTargetX = (width - panelWidth) / 2;
                targetX = screenTargetX - (node.destX * camera.zoom);
            }

            setTimeout(() => {
                panelTitle.innerText = node.id;
                panelDesc.innerText = node.desc;
                sidePanel.classList.add('active');
            }, 50);

            camera.targetX = targetX;
            camera.targetY = (height / 2) - (node.destY * camera.zoom);
        }

        window.onload = () => { calculateLayout(); animate(); };
        window.addEventListener('resize', calculateLayout);

        window.addEventListener('click', (e) => {
            if(e.target.closest('#sidePanel')) return;

            if (!camera.isDragging) {
                let clickedNode = null;
                for (let i = particles.length - 1; i >= 0; i--) {
                    if (particles[i].visible && particles[i].hovered) {
                        clickedNode = particles[i];
                        break;
                    }
                }

                if (clickedNode) {
                    handleNodeClick(clickedNode);
                } else {
                    closePanel();
                }
            }
        });
    </script>
</body>
</html>
