<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hey there</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Scrollbarları gizle */
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- AYARLAR ---
        const SPEED = 0.02;           // İlerleme hızı
        const CURVE_INTENSITY = 8;    // Kıvrımların keskinliği
        const MORPH_SPEED = 0.002;    // Tünelin şekil değiştirme hızı
        const TUBE_RADIUS = 4;        // Tünel genişliği
        
        // --- SAHNE KURULUMU ---
        const scene = new THREE.Scene();
        // Uzayın derinliği için sis (Fog) - Sonunu görmememiz lazım
        scene.fog = new THREE.FogExp2(0x000000, 0.08);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- DOKU (TEXTURE) OLUŞTURMA ---
        // Işık hızı çizgileri efekti için özel canvas dokusu
        function createHyperspaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Arkaplan
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 1024, 1024);

            // Parlak Çizgiler (Streaks)
            for(let i=0; i<300; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const w = Math.random() * 3 + 1;
                const h = Math.random() * 300 + 100; // Çok uzun çizgiler
                
                // Neon renk paleti (Mavi, Cyan, Beyaz)
                const hue = Math.random() > 0.5 ? 200 + Math.random() * 40 : 180; 
                ctx.fillStyle = `hsl(${hue}, 100%, ${50 + Math.random() * 50}%)`;
                
                ctx.globalAlpha = Math.random() * 0.8;
                ctx.fillRect(x, y, w, h);
            }
            
            // Ekstra parıltı katmanı
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00ffff";

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1); // Dokuyu yay
            return texture;
        }

        const texture = createHyperspaceTexture();

        // --- TÜNEL GEOMETRİSİ ---
        // Tünelin iskeletini oluşturacak noktalar dizisi
        const points = [];
        for (let i = 0; i < 50; i++) {
            // Başlangıçta hafif kıvrımlı bir yol
            points.push(new THREE.Vector3(
                Math.sin(i * 0.2) * 10, 
                Math.cos(i * 0.1) * 10, 
                i * -5 // Z ekseninde içeri doğru
            ));
        }

        // Eğriyi oluştur
        let curve = new THREE.CatmullRomCurve3(points);
        
        // Başlangıç geometrisi
        let geometry = new THREE.TubeGeometry(curve, 70, TUBE_RADIUS, 16, false);
        
        const material = new THREE.MeshBasicMaterial({ 
            map: texture,
            side: THREE.BackSide, // İçerden bakıyoruz
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending // Parlaklık efekti verir
        });

        const tubeMesh = new THREE.Mesh(geometry, material);
        scene.add(tubeMesh);

        // --- ANİMASYON DEĞİŞKENLERİ ---
        let time = 0;
        
        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += MORPH_SPEED;

            // 1. DOKU HAREKETİ (Hız hissi)
            // Dokuyu Y ekseninde kaydırarak ileri gidiyormuş hissi veriyoruz
            texture.offset.y += SPEED;
            texture.offset.x -= 0.002; // Hafifçe yana da dönsün

            // 2. GEOMETRİ DEĞİŞİMİ (Kıvrımların değişmesi)
            // Tünelin omurgasını oluşturan noktaları zamanla oynatıyoruz
            for (let i = 0; i < points.length; i++) {
                // Her noktanın X ve Y koordinatını sinüs dalgaları ile değiştir
                // i değişkenini de işin içine katarak dalgalanma efekti yapıyoruz
                points[i].x = Math.sin(time * 2 + i * 0.3) * CURVE_INTENSITY;
                points[i].y = Math.cos(time * 1.5 + i * 0.2) * CURVE_INTENSITY;
            }

            // Eğriyi güncelle
            curve = new THREE.CatmullRomCurve3(points);
            
            // Geometriyi tamamen yenile (Eski geometriyi bellekten silmek önemli)
            tubeMesh.geometry.dispose();
            tubeMesh.geometry = new THREE.TubeGeometry(curve, 70, TUBE_RADIUS, 16, false);

            // 3. KAMERA HAREKETİ
            // Kamerayı tünelin biraz içinde tutuyoruz
            // Ama aslında biz tüneli değiştirip dokuyu kaydırdığımız için
            // kamera nispeten sabit kalsa bile ilerliyormuşuz gibi olur.
            // Yine de kamerayı curve'ün ilk segmentine göre yönlendirelim.
            
            const p1 = curve.getPointAt(0.05); // Kameranın olduğu yer
            const p2 = curve.getPointAt(0.1);  // Baktığı yer

            camera.position.copy(p1);
            camera.lookAt(p2);

            // Kamerayı tünelin kıvrımına göre biraz yatır (Banking effect)
            camera.rotation.z += Math.sin(time) * 0.01;

            renderer.render(scene, camera);
        }

        animate();

        // Pencere boyutu değişirse
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
