<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Mind Map</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@900&family=Inter:wght@300;500;800&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: transparent;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            cursor: default;
            touch-action: none; 
            -webkit-user-select: none;
        }

        #bgVideo {
            position: fixed;
            right: 0; bottom: 0;
            min-width: 100%; min-height: 100%;
            width: auto; height: auto;
            z-index: -2;
            object-fit: cover;
            opacity: 0.8;
        }

        #canvas1 { 
            display: block; 
            width: 100vw; height: 100vh;
            position: relative; z-index: 1; 
        }

        /* --- MASAÜSTÜ PANELİ --- */
        #sidePanel {
            position: fixed;
            top: 0;
            width: 350px; height: 100%;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            padding: 40px;
            color: #000;
            z-index: 10;
            transition: transform 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 0 40px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
        }
        
        #sidePanel.right {
            right: 0; left: auto;
            transform: translateX(100%);
            border-left: 1px solid rgba(0,0,0,0.1);
        }
        #sidePanel.right.active { transform: translateX(0); }

        #sidePanel.left {
            left: 0; right: auto;
            transform: translateX(-100%);
            border-right: 1px solid rgba(0,0,0,0.1);
        }
        #sidePanel.left.active { transform: translateX(0); }

        #panelTitle {
            font-family: 'Playfair Display', serif;
            font-size: 32px; margin-bottom: 20px;
            color: #000; 
        }
        #panelDesc {
            font-size: 16px; line-height: 1.6; color: #333; margin-bottom: 30px;
        }
        #closeBtn {
            position: absolute; top: 20px; right: 20px;
            background: none; border: none; color: #000;
            font-size: 24px; cursor: pointer;
        }
        #closeBtn:hover { color: #555; }

        /* --- MOBİL GİZLEME --- */
        @media (max-width: 768px) {
            #sidePanel { display: none !important; }
            .info {
                width: 90%;
                text-align: center;
                bottom: 30px !important;
                left: 5% !important;
                font-size: 14px !important;
                background: rgba(255, 255, 255, 0.9) !important;
                color: #000 !important;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            }
        }

        .info {
            position: absolute; bottom: 20px; left: 20px;
            color: #000; font-size: 13px; pointer-events: none; user-select: none;
            background: rgba(255,255,255,0.6); padding: 8px 12px; border-radius: 8px;
            z-index: 2; 
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <video autoplay muted loop playsinline id="bgVideo">
        <source src="bg.mp4" type="video/mp4">
        Tarayıcınız video etiketini desteklemiyor.
    </video>

    <div id="sidePanel" class="right">
        <button id="closeBtn">&times;</button>
        <h2 id="panelTitle">Başlık</h2>
        <p id="panelDesc">Detaylar...</p>
        <div style="margin-top: auto; font-size: 12px; color: #555;">
            ● exploration made easy
        </div>
    </div>

    <canvas id="canvas1"></canvas>
    <div class="info" id="infoBox">exploration made easy</div>

    <script>
        const mainNodeText = "hey!";
        const isMobile = window.innerWidth <= 768;
        const infoBox = document.getElementById('infoBox');

        const myData = {
            nodes: [
                { id: mainNodeText, group: 'main', val: 100, desc: "Burası benim kişisel evrenim. Hoş geldin." },
                { id: 'TEKNOLOJİ', group: 'cat', val: 50, parent: mainNodeText, desc: "Kod, devreler ve silikon vadisi maceralarım." },
                { id: 'FİZİK & BİLİM', group: 'cat', val: 50, parent: mainNodeText, desc: "Evrenin nasıl çalıştığını anlama çabam." },
                { id: 'SANAT & TASARIM', group: 'cat', val: 50, parent: mainNodeText, desc: "Estetik, renkler ve dijital sanat." },
                { id: 'YAŞAM', group: 'cat', val: 50, parent: mainNodeText, desc: "Hobilerim, gezilerim ve yaşam tarzım." },
                { id: 'Yazılım', group: 'sub', val: 30, parent: 'TEKNOLOJİ', desc: "Backend, Frontend ve ötesi." },
                { id: 'Robotik', group: 'sub', val: 30, parent: 'TEKNOLOJİ', desc: "Hareket eden makineler." },
                { id: 'Python', group: 'item', val: 15, parent: 'Yazılım', desc: "Veri bilimi ve otomasyon için favori dilim." },
                { id: 'Three.js', group: 'item', val: 15, parent: 'Yazılım', desc: "Web üzerinde 3D dünyalar yaratmak." },
                { id: 'GitHub', group: 'item', val: 12, parent: 'Yazılım', desc: "Açık kaynak katkılarım." },
                { id: 'Arduino', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Pixhawk', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Jetson Xavier', group: 'item', val: 12, parent: 'Robotik' },
                { id: 'Simülasyon', group: 'sub', val: 30, parent: 'FİZİK & BİLİM' },
                { id: 'Teori', group: 'sub', val: 30, parent: 'FİZİK & BİLİM' },
                { id: 'Yörünge Mekaniği', group: 'item', val: 15, parent: 'Simülasyon' },
                { id: 'Euler Metodu', group: 'item', val: 15, parent: 'Simülasyon' },
                { id: 'NumPy', group: 'item', val: 12, parent: 'Simülasyon' },
                { id: 'Lineer Cebir', group: 'item', val: 15, parent: 'Teori' },
                { id: 'Solucan Delikleri', group: 'item', val: 12, parent: 'Teori' },
                { id: '3D Modelleme', group: 'sub', val: 30, parent: 'SANAT & TASARIM' },
                { id: 'Görsel Estetik', group: 'sub', val: 30, parent: 'SANAT & TASARIM' },
                { id: 'Blender', group: 'item', val: 15, parent: '3D Modelleme', desc: "3D modeller ve renderlar." },
                { id: 'Renk Teorisi', group: 'item', val: 12, parent: 'Görsel Estetik', desc: "Renklerin psikolojisi ve uyumu." },
                { id: 'Fraktallar', group: 'item', val: 15, parent: 'Görsel Estetik' },
                { id: 'Minimalizm', group: 'item', val: 12, parent: 'Görsel Estetik' },
                { id: 'Kariyer', group: 'sub', val: 30, parent: 'YAŞAM' },
                { id: 'Hobiler', group: 'sub', val: 30, parent: 'YAŞAM' },
                { id: 'Erasmus', group: 'item', val: 15, parent: 'Kariyer' },
                { id: 'Fransızca', group: 'item', val: 12, parent: 'Kariyer' },
                { id: 'Calisthenics', group: 'item', val: 15, parent: 'Hobiler' },
                { id: 'Handstand', group: 'item', val: 12, parent: 'Hobiler' },
                { id: 'Moda', group: 'item', val: 12, parent: 'Hobiler' }
            ]
        };

        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        const sidePanel = document.getElementById('sidePanel');
        const panelTitle = document.getElementById('panelTitle');
        const panelDesc = document.getElementById('panelDesc');
        const closeBtn = document.getElementById('closeBtn');

        // Genişlik ve Yüksekliği baştan hesapla
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        let particles = [];
        let particleMap = {};
        let auraParticles = []; 
        let activeNode = null; 
        let cursorParticles = [];

        // KAMERA BAŞLANGIÇ POZİSYONUNU DOĞRUDAN MERKEZE AYARLA
        let camera = { 
            x: width / 2, // 0 yerine direkt merkez
            y: height / 2, // 0 yerine direkt merkez
            zoom: isMobile ? 0.6 : 1,
            targetX: width / 2, 
            targetY: height / 2, 
            isDragging: false, startX: 0, startY: 0 
        };
        
        let mouse = { x: -100, y: -100, worldX: 0, worldY: 0 };
        
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                camera.isDragging = true;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                camera.startX = e.touches[0].clientX - camera.x;
                camera.startY = e.touches[0].clientY - camera.y;
            }
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); 
            if (camera.isDragging && e.touches.length === 1) {
                camera.x = e.touches[0].clientX - camera.startX;
                camera.y = e.touches[0].clientY - camera.startY;
                camera.targetX = camera.x;
                camera.targetY = camera.y;
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            camera.isDragging = false;
            let touchEndX = e.changedTouches[0].clientX;
            let touchEndY = e.changedTouches[0].clientY;
            let dist = Math.hypot(touchEndX - touchStartX, touchEndY - touchStartY);

            if (dist < 10) {
                let tx = touchEndX;
                let ty = touchEndY;
                let wx = (tx - camera.x) / camera.zoom;
                let wy = (ty - camera.y) / camera.zoom;
                checkClick(wx, wy);
            }
        });

        if (!isMobile) {
            window.addEventListener('mousedown', e => {
                if(e.target.closest('#sidePanel')) return;
                camera.isDragging = true;
                camera.startX = e.clientX - camera.x;
                camera.startY = e.clientY - camera.y;
            });
            window.addEventListener('mouseup', () => { camera.isDragging = false; });
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
                if (camera.isDragging) {
                    camera.x = e.clientX - camera.startX;
                    camera.y = e.clientY - camera.startY;
                    camera.targetX = camera.x;
                    camera.targetY = camera.y;
                }
                mouse.worldX = (mouse.x - camera.x) / camera.zoom;
                mouse.worldY = (mouse.y - camera.y) / camera.zoom;
            });
        }
        
        window.addEventListener('wheel', e => {
            e.preventDefault();
            const s = 0.001;
            const newZoom = Math.max(0.2, Math.min(camera.zoom - e.deltaY * s, 4));
            const wx = (mouse.x - camera.x) / camera.zoom;
            const wy = (mouse.y - camera.y) / camera.zoom;
            camera.zoom = newZoom;
            camera.x = mouse.x - wx * camera.zoom;
            camera.y = mouse.y - wy * camera.zoom;
            camera.targetX = camera.x;
            camera.targetY = camera.y;
        }, { passive: false });


        function closePanel() {
            sidePanel.classList.remove('active');
            infoBox.innerText = "exploration made easy";
            activeNode = null;
            auraParticles = []; 
            // Reset to Center
            camera.targetX = width/2;
            camera.targetY = height/2;
        }

        closeBtn.addEventListener('click', closePanel);

        class CursorSwarm {
            constructor() {
                this.x = mouse.x; this.y = mouse.y;
                this.size = Math.random() * 2 + 1;
                this.angle = Math.random() * Math.PI * 2;
                this.offset = Math.random() * 20;
            }
            update() {
                this.angle += 0.05;
                let targetX = mouse.x + Math.cos(this.angle) * this.offset;
                let targetY = mouse.y + Math.sin(this.angle) * this.offset;
                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;
            }
            draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class AuraParticle {
            constructor(originX, originY, type) {
                this.originX = originX; this.originY = originY; this.type = type;
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 50 + Math.random() * 150; 
                this.x = this.originX + Math.cos(this.angle) * this.radius;
                this.y = this.originY + Math.sin(this.angle) * this.radius;
                this.angularSpeed = (Math.random() - 0.5) * 0.02;
                this.originalRadius = this.radius;
                this.life = 0; this.maxLife = 0.6 + Math.random() * 0.4; 

                if (type.includes('SANAT')) { this.color = `rgba(100, 50, 50, 0.4)`; this.size = Math.random() * 4 + 2; } 
                else if (type.includes('TEKNOLOJİ')) { this.color = `rgba(50, 80, 50, 0.4)`; this.size = Math.random() * 3 + 1; } 
                else { this.color = 'rgba(50, 50, 50, 0.4)'; this.size = Math.random() * 3 + 1; }
            }
            update() {
                if (this.life < this.maxLife) this.life += 0.02;
                this.angle += this.angularSpeed;
                let currentRadius = this.originalRadius + Math.sin(Date.now() * 0.002 + this.originalRadius) * 20;
                this.x = this.originX + Math.cos(this.angle) * currentRadius;
                this.y = this.originY + Math.sin(this.angle) * currentRadius;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                if (this.type.includes('TEKNOLOJİ')) ctx.fillRect(this.x, this.y, this.size, this.size);
                else { ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
                ctx.globalAlpha = 1;
            }
        }

        function createAura(node) {
            auraParticles = []; 
            let type = node.group === 'cat' ? node.id : (node.parent || node.id);
            for(let i=0; i<60; i++) {
                auraParticles.push(new AuraParticle(node.x, node.y + node.floatOffset, type));
            }
        }

        class Particle {
            constructor(data) {
                this.id = data.id; this.group = data.group; this.val = data.val; this.parentId = data.parent;
                this.desc = data.desc || "Detaylar yakında...";
                this.destX = 0; this.destY = 0; this.x = 0; this.y = 0;
                this.visible = (this.group === 'main');
                this.scale = this.visible ? 1 : 0; this.opacity = this.visible ? 1 : 0;
                this.floatAngle = Math.random()*Math.PI*2; this.floatOffset = 0;
                this.hovered = false;
            }
            update() {
                if (!this.visible) return;
                this.x += (this.destX - this.x) * 0.08; 
                this.y += (this.destY - this.y) * 0.08;
                if (this.scale < 1) this.scale += (1 - this.scale) * 0.1;
                if (this.opacity < 1) this.opacity += (1 - this.opacity) * 0.1;
                
                this.floatAngle += 0.002;
                this.floatOffset = Math.sin(this.floatAngle) * 4; 

                if (!isMobile) {
                    let textW = this.val * 3 + 50; 
                    let textH = this.val + 30;
                    if (mouse.worldX > this.x - textW/2 && mouse.worldX < this.x + textW/2 &&
                        mouse.worldY > this.y - textH/2 + this.floatOffset && mouse.worldY < this.y + textH/2 + this.floatOffset) {
                        this.hovered = true;
                    } else {
                        this.hovered = false;
                    }
                }
            }
            draw() {
                if (!this.visible || this.opacity < 0.01) return;
                ctx.save();
                ctx.translate(this.x, this.y + this.floatOffset);
                ctx.scale(this.scale, this.scale);
                ctx.globalAlpha = this.opacity;

                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                let fontSize = isMobile ? 12 : 14; 
                let color = '#000000';

                if (this.group === 'main') {
                    fontSize = isMobile ? 36 : 50; 
                    ctx.font = `900 ${fontSize}px 'Playfair Display', serif`;
                } else if (this.group === 'cat') {
                    fontSize = isMobile ? 20 : 28; 
                    ctx.font = `800 ${fontSize}px 'Inter', sans-serif`; color = '#111';
                } else if (this.group === 'sub') {
                    fontSize = isMobile ? 14 : 18; 
                    ctx.font = `600 ${fontSize}px 'Inter', sans-serif`; color = '#222';
                } else {
                    ctx.font = `400 ${fontSize}px 'JetBrains Mono', monospace`; color = '#333';
                }

                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ffffff'; 
                ctx.strokeText(this.id, 0, 0);
                
                if (this.hovered || activeNode === this) {
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#000'; 
                    ctx.strokeText(this.id, 0, 0);
                    ctx.fillText(this.id, 0, 0);
                } else {
                    ctx.fillStyle = color;
                    ctx.fillText(this.id, 0, 0);
                }
                
                ctx.restore();
            }
        }

        function calculateLayout() {
            // Layout hesaplanırken genişlik yüksekliği güncelle
            width = window.innerWidth; 
            height = window.innerHeight;
            canvas.width = width; 
            canvas.height = height;

            if(!isMobile && cursorParticles.length === 0) {
                for(let i=0; i<12; i++) cursorParticles.push(new CursorSwarm());
            }

            if (particles.length === 0) {
                myData.nodes.forEach(node => {
                    let p = new Particle(node);
                    particles.push(p);
                    particleMap[node.id] = p;
                });
            }

            let pMain = particles.find(p => p.group === 'main');
            if(pMain && !pMain.visible) { pMain.x = 0; pMain.y = 0; }

            let cats = particles.filter(p => p.group === 'cat');
            let r1 = isMobile ? 180 : 300; 
            
            cats.forEach((p, i) => {
                let angle = (Math.PI*2 / cats.length) * i - Math.PI/2;
                p.destX = Math.cos(angle) * r1;
                p.destY = Math.sin(angle) * r1;
                
                let subs = particles.filter(sub => sub.parentId === p.id);
                if (subs.length > 0) {
                    let spread = Math.PI / 1.5;
                    let startA = angle - spread/2;
                    let r2 = r1 + (isMobile ? 160 : 280);
                    subs.forEach((sub, j) => {
                        let subA = startA + (spread/(subs.length+1))*(j+1);
                        sub.destX = Math.cos(subA) * r2;
                        sub.destY = Math.sin(subA) * r2;
                        let items = particles.filter(it => it.parentId === sub.id);
                        if (items.length > 0) {
                            let itemBaseA = Math.atan2(sub.destY, sub.destX);
                            let r3 = isMobile ? 120 : 200;
                            items.forEach((item, k) => {
                                let offset = (k - (items.length-1)/2) * 0.35;
                                let itemA = itemBaseA + offset;
                                item.destX = sub.destX + Math.cos(itemA) * r3;
                                item.destY = sub.destY + Math.sin(itemA) * r3;
                            });
                        }
                    });
                }
            });
        }

        function drawOrganicLinks() {
            ctx.globalCompositeOperation = 'source-over';
            particles.forEach(p => {
                if (!p.visible || !p.parentId || p.opacity < 0.1) return;
                let parent = particleMap[p.parentId];
                if (!parent) return;

                let startX = parent.x; let startY = parent.y + parent.floatOffset;
                let endX = p.x; let endY = p.y + p.floatOffset;
                let dist = Math.hypot(endX - startX, endY - startY);
                if (dist < 10) return;

                ctx.globalAlpha = p.opacity * 0.5; 
                let dx = endX - startX; let dy = endY - startY;
                let perpX = -dy / dist; let perpY = dx / dist;
                let t1 = 0.3; let cp1X = startX + dx * t1 + perpX * 50; let cp1Y = startY + dy * t1 + perpY * 50;
                let t2 = 0.7; let cp2X = startX + dx * t2 - perpX * 50; let cp2Y = startY + dy * t2 - perpY * 50;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, endX, endY);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.lineWidth = isMobile ? 1 : 1.5; 
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, width, height);

            camera.x += (camera.targetX - camera.x) * 0.08;
            camera.y += (camera.targetY - camera.y) * 0.08;

            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            drawOrganicLinks();
            for(let i = 0; i < auraParticles.length; i++) { auraParticles[i].update(); auraParticles[i].draw(); }
            particles.forEach(p => { p.update(); p.draw(); });
            ctx.restore();

            if(!isMobile) {
                for(let i=0; i<cursorParticles.length; i++) { cursorParticles[i].update(); cursorParticles[i].draw(); }
            }
        }

        function handleNodeClick(node) {
            if (activeNode === node) { closePanel(); return; }
            activeNode = node;

            let children = particles.filter(p => p.parentId === node.id && !p.visible);
            children.forEach(child => { child.x = node.x; child.y = node.y; child.scale = 0; child.visible = true; });

            createAura(node);
            
            if (isMobile) {
                infoBox.innerText = node.desc;
                camera.targetX = (width / 2) - (node.destX * camera.zoom);
                camera.targetY = (height / 2) - (node.destY * camera.zoom);
            } else {
                sidePanel.classList.remove('active'); 
                let panelWidth = 350;
                let targetX = 0;
                if (node.destX > 0) {
                    sidePanel.classList.remove('right'); sidePanel.classList.add('left');
                    let screenTargetX = (panelWidth + width) / 2;
                    targetX = screenTargetX - (node.destX * camera.zoom);
                } else {
                    sidePanel.classList.remove('left'); sidePanel.classList.add('right');
                    let screenTargetX = (width - panelWidth) / 2;
                    targetX = screenTargetX - (node.destX * camera.zoom);
                }
                setTimeout(() => {
                    panelTitle.innerText = node.id;
                    panelDesc.innerText = node.desc;
                    sidePanel.classList.add('active');
                }, 50);
                camera.targetX = targetX;
                camera.targetY = (height / 2) - (node.destY * camera.zoom);
            }
        }

        function checkClick(wx, wy) {
            let clickedNode = null;
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                if (!p.visible) continue;
                let dist = Math.hypot(p.x - wx, p.y - wy);
                let hitSize = p.val + 20; 
                if (dist < hitSize) {
                    clickedNode = p;
                    break;
                }
            }

            if (clickedNode) {
                handleNodeClick(clickedNode);
            } else {
                closePanel();
            }
        }

        window.onload = () => { 
            // Sayfa yüklendiğinde boyutları güncelle ve kamerayı ortala
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Kamerayı zorla merkeze al
            camera.x = width / 2;
            camera.y = height / 2;
            camera.targetX = width / 2;
            camera.targetY = height / 2;
            
            calculateLayout(); 
            animate(); 
        };
        
        window.addEventListener('resize', () => {
             calculateLayout();
             // Resize olunca da kamerayı ortala (aktif node yoksa)
             if(!activeNode) {
                camera.targetX = width/2;
                camera.targetY = height/2;
             }
        });

        if (!isMobile) {
            window.addEventListener('click', (e) => {
                if(e.target.closest('#sidePanel')) return;
                if (!camera.isDragging) {
                    checkClick(mouse.worldX, mouse.worldY);
                }
            });
        }
    </script>
</body>
</html>
